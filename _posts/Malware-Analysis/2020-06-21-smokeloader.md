---
title: "Deep Analysis of SmokeLoader"
classes: wide
header:
  teaser: /assets/malware-analysis/smokeloader/logo1.gif
ribbon: DodgerBlue
description: "SmokeLoader is a well known bot that is been around since 2011. It's mainly used to drop other malware families..."
categories:
  - Malware Analysis
toc: true
---

SmokeLoader is a well known bot that is been around since 2011. It's mainly used to drop other malware families. SmokeLoader has been under development and is constantly changing with multiple novel features added throughout the years.

`Sample SHA256: fc20b03299b8ae91e72e104ee4f18e40125b2b061f1509d1c5b3f9fac3104934`

[![0](/assets/images/malware-analysis/smokeloader/0.png)](/assets/images/malware-analysis/smokeloader/0.png)

# Stage 1

This stage starts off by allocating memory for `shellcode` using `LocalAlloc()` (not VirtualAlloc), then it fills this memory with the shellcode (86 KB).

[![1](/assets/images/malware-analysis/smokeloader/1.png)](/assets/images/malware-analysis/smokeloader/1.png)

Next, it changes the protection of the allocated memory region to `PAGE_EXECUTE_READWRITE` using `VirtualProtect()`, then it writes the shellcode and executes it.

[![2](/assets/images/malware-analysis/smokeloader/2.png)](/assets/images/malware-analysis/smokeloader/2.png)

## Shellcode

The shellcode starts by getting the addresses of `LoadLibraryA` and `GetProcAddress` to resolve APIs dynamically, but first let's see how it does that.

First it passes some hash values to a sub-routine that returns the address of the requested function.

[![3](/assets/images/malware-analysis/smokeloader/3.png)](/assets/images/malware-analysis/smokeloader/3.png)

After some digging, I found out that the algorithm for calculating the hashes is pretty simple.

```c
int calc_hash(char* name) {
    int x, hash = 0;
    for(int i=0; i<strlen(name); i++) {
        x = name[i] | 0x60;
        hash = 2 * (x + hash);
    }
    return hash;
}
```

The shellcode uses `PEB traversal` technique for finding a function.

> Process Environment Block (PEB) is a user-mode data structure that can be used by applications (and by extend by malware) to  get information such as the list of loaded modules, process startup  arguments, heap address among other useful capabilities.

The shellcode traverses the PEB structure at `FS[:30]` and iterating through loaded modules to search for the requested module (kernel32 in this case). It hashes the name of each module using the algorithm above and compares it with the supplied hash.

Next, it iterates over the export table of the module to find the requested function, similar to the previous step.

[![4](/assets/images/malware-analysis/smokeloader/4.png)](/assets/images/malware-analysis/smokeloader/4.png) | [![5](/assets/images/malware-analysis/smokeloader/5.png)](/assets/images/malware-analysis/smokeloader/5.png) 

The next step is to resolve APIs using `LoadLibraryA` and `GetProcAddress`, the shellcode uses stack strings to complicate the analysis.

[![6](/assets/images/malware-analysis/smokeloader/6.png)](/assets/images/malware-analysis/smokeloader/6.png)

Here is the list of imported functions:

<details style="color: #EEFFFF; font-family: monospace !default; font-size: 0.85em; background: #263238; border: 1px solid #263238; border-radius: 3px; padding: 10px; line-height: 1.8">
    <summary style="outline: none; cursor: pointer">
        <span style="color: darkgray">
            Expand to see more
        </span><br>
&emsp; ntdll.dll<br>
&emsp; &emsp; &ensp; NtUnmapViewOfSection<br>
&emsp; &emsp; &ensp; NtWriteVirtualMemory<br>
&emsp; kernel32.dll<br>
&emsp; &emsp; &ensp; CloseHandle<br>
&emsp; &emsp; &ensp; CreateFileA<br>
&emsp; &emsp; &ensp; CreateProcessA<br>
&emsp; &emsp; &ensp; ExitProcess<br>
&emsp; &emsp; &ensp; GetCommandLineA<br>
</summary>
&emsp; &emsp; &ensp; GetFileAttributesA<br>
&emsp; &emsp; &ensp; GetModuleFileNameA<br>
&emsp; &emsp; &ensp; GetStartupInfoA<br>
&emsp; &emsp; &ensp; GetThreadContext<br>
&emsp; &emsp; &ensp; ReadProcessMemory<br>
&emsp; &emsp; &ensp; ResumeThread<br>
&emsp; &emsp; &ensp; SetThreadContext<br>
&emsp; &emsp; &ensp; VirtualAlloc<br>
&emsp; &emsp; &ensp; VirtualAllocEx<br>
&emsp; &emsp; &ensp; VirtualFree<br>
&emsp; &emsp; &ensp; VirtualProtectEx<br>
&emsp; &emsp; &ensp; WaitForSingleObject<br>
&emsp; &emsp; &ensp; WinExec<br>
&emsp; &emsp; &ensp; WriteFile<br>
&emsp; &emsp; &ensp; WriteProcessMemory<br>
&emsp; user32.dll<br>
&emsp; &emsp; &ensp; CreateWindowExA<br>
&emsp; &emsp; &ensp; DefWindowProcA<br>
&emsp; &emsp; &ensp; GetMessageA<br>
&emsp; &emsp; &ensp; GetMessageExtraInfo<br>
&emsp; &emsp; &ensp; MessageBoxA<br>
&emsp; &emsp; &ensp; PostMessageA<br>
&emsp; &emsp; &ensp; RegisterClassExA<br>
</details>
## Process Hollowing

The shellcode creates a new processes of SmokeLoader in a suspended state.

[![7](/assets/images/malware-analysis/smokeloader/7.png)](/assets/images/malware-analysis/smokeloader/7.png)

Next, it hollows out the memory at `0x400000` using `ZwUnmapViewOfSection()` and then allocates it again using `VirtualAllocEx()` with `RWX` permissions.

Finally, it writes the next stage executable to the allocated memory region using two calls to `ZwWriteVirtualMemory()`, the first one to write the MZ header and the other for the rest of the executable.

[![8](/assets/images/malware-analysis/smokeloader/8.png)](/assets/images/malware-analysis/smokeloader/8.png)

# Stage 2

After dumping the second stage from memory, I got a warm welcome from SmokeLoader :(

[![9](/assets/images/malware-analysis/smokeloader/9.png)](/assets/images/malware-analysis/smokeloader/9.png)

This stage is full of anti-analysis tricks, so let's dive in.

## Opaque Predicates

The first anti-analysis trick is [Opaque Predicates](https://en.wikipedia.org/wiki/Opaque_predicate), it's a commonly used technique in program obfuscation, intended to add complexity to the control flow. There are many patterns of this technique so I will stick with the one used here.

This obfuscation simply takes an absolute jump (JMP) and transforms it into two conditional jumps (JZ/JNZ). Depending on the value of the `Zero flag (ZF)`, the execution will follow the first or second branch.

However, disassemblers are tricked into thinking that there is a fall-through branch if the second jump is not taken (which is impossible as one of them must be taken) and tries to disassemble the unreachable instructions (often invalid) resulting in garbage code.

 [![10](/assets/images/malware-analysis/smokeloader/10.png)](/assets/images/malware-analysis/smokeloader/10.png)

The deobfuscation is so simple, we just need to patch the first conditional jump to an absolute jump and nop out the second jump, we can use `IDAPython` to achieve this:

```python
import idc

ea = 0
while True:
    ea =  min(idc.find_binary(ea, idc.SEARCH_NEXT | idc.SEARCH_DOWN, "74 ? 75 ?"),  # JZ / JNZ
              idc.find_binary(ea, idc.SEARCH_NEXT | idc.SEARCH_DOWN, "75 ? 74 ?"))  # JNZ / JZ
    if ea == idc.BADADDR:
    	break
    idc.patch_byte(ea, 0xEB)	# JMP
    idc.patch_byte(ea+2, 0x90)	# NOP
    idc.patch_byte(ea+3, 0x90)	# NOP
```

## Anti Debugging

This stage first checks `OSMajorVersion at PEB[0xA4]` if it's greater than 6 (Windows Vista and higher), it's also reading `BeingDebugged at PEB[0x2]` to check for attached debuggers.

[![11](/assets/images/malware-analysis/smokeloader/11.png)](/assets/images/malware-analysis/smokeloader/11.png)

What's interesting here is that these checks are used to calculate the return address. If the `OSMajroVersion` is less than 6 or there's an attached debugger, it will jump to an invalid memory location. That's clever.

Another neat trick is that instead of using direct jumps, the code pushes the jump address stored at `eax`  into the stack then returns to it.

[![12](/assets/images/malware-analysis/smokeloader/12.png)](/assets/images/malware-analysis/smokeloader/12.png)

## Encrypted Functions

Most of the functions are encrypted. After deobfuscating the opaque predicates, I found the encryption function which is pretty simple.

The function takes an offset and a size, it XORes the chunk at that offset with a single byte `(0xA6)`.

[![13](/assets/images/malware-analysis/smokeloader/13.png)](/assets/images/malware-analysis/smokeloader/13.png)

We can use `IDAPython` again to decrypt the encrypted chunks:

```python
import idc
import idautils

def xor_chunk(offset, n):
	ea = 0x400000 + offset
	for i in range(n):
		byte = ord(idc.get_bytes(ea+i, 1))
		byte ^= 0xA6
		idc.patch_byte(ea+i, byte)

xor_chunk_addr = 0x401294	# address of the xoring function
for xref in idautils.CodeRefsTo(xor_chunk_addr, 0):
	mov_addr = list(idautils.CodeRefsTo(xref, 0))[0] - 5
	n = idc.get_operand_value(mov_addr, 1)
	offset = (xref + 5) - 0x400000
	xor_chunk(offset, n)
```

After the decryption:

[![14](/assets/images/malware-analysis/smokeloader/14.png)](/assets/images/malware-analysis/smokeloader/14.png)

One thing to note here, SmokeLoader tries to keep as many encrypted code as possible. So once it's done with the decrypted functions, it encrypts it again.

[![15](/assets/images/malware-analysis/smokeloader/15.png)](/assets/images/malware-analysis/smokeloader/15.png)

## Anti Hooking

Many Sandboxes and Security Solutions hook user-land functions of `ntdll.dll` to trace system calls. SmokeLoader tries to evade this by using its own copy of ntdll. It copies `ntdll.dll` to `"%TEMP%\<hardcoded_name>.tmp"` then loads it using `LdrLoadDll()` and resolves its imports from it.

[![16](/assets/images/malware-analysis/smokeloader/16.png)](/assets/images/malware-analysis/smokeloader/16.png)

## Custom Imports

SmokeLoader stores a hash table of its imports, it uses the same `PEB traversal` technique explained earlier to walk through the DLLs' export table and compare the hash of each API name with the stored hashes.

The hashing function is an implementation of `djb2` hashing algorithms:

```c
int calc_hash(char *api_name) {
	int hash=0x1505;
	for(int i=0; i<=strlen(api_name); i++)	// null byte included
		hash = ((hash << 5) + hash) + api_name[i];
	return hash;
}
```

Here is a list of imported functions and their corresponding hashes:

<details style="color: #EEFFFF; font-family: monospace !default; font-size: 0.85em; background: #263238; border: 1px solid #263238; border-radius: 3px; padding: 10px; line-height: 1.8">
    <summary style="outline: none; cursor: pointer">
        <span style="color: darkgray">
            Expand to see more
        </span><br>
&emsp; ntdll.dll<br>
&emsp; &emsp; &ensp; LdrLoadDll                  (0x64033f83)<br>
&emsp; &emsp; &ensp; NtClose                     (0xfd507add)<br>
&emsp; &emsp; &ensp; NtTerminateProcess          (0xf779110f)<br>
&emsp; &emsp; &ensp; RtlInitUnicodeString        (0x60a350a9)<br>
&emsp; &emsp; &ensp; RtlMoveMemory               (0x845136e7)<br>
&emsp; &emsp; &ensp; RtlZeroMemory               (0x8a3d4cb0)<br>
&emsp; kernel32.dll<br>
&emsp; &emsp; &ensp; CopyFileW                   (0x306cceb7)<br>
&emsp; &emsp; &ensp; CreateEventW                (0xfd4027f2)<br>
</summary>
&emsp; &emsp; &ensp; CreateFileMappingW          (0x5b3f901c)<br>
&emsp; &emsp; &ensp; CreateThread                (0x60277e71)<br>
&emsp; &emsp; &ensp; DeleteFileW                 (0xb7e96d0f)<br>
&emsp; &emsp; &ensp; ExpandEnvironmentStringsW   (0x057074bb)<br>
&emsp; &emsp; &ensp; GetModuleFileNameA          (0x8acccaed)<br>
&emsp; &emsp; &ensp; GetModuleFileNameW          (0x8acccdc3)<br>
&emsp; &emsp; &ensp; GetModuleHandleA            (0x9cbd2a58)<br>
&emsp; &emsp; &ensp; GetSystemDirectoryA         (0xaebc5060)<br>
&emsp; &emsp; &ensp; GetTempFileNameW            (0x9a376a33)<br>
&emsp; &emsp; &ensp; GetTempPathW                (0x7e28b9df)<br>
&emsp; &emsp; &ensp; GetVolumeInformationA       (0xf25ce6a4)<br>
&emsp; &emsp; &ensp; LocalAlloc                  (0xeda647bb)<br>
&emsp; &emsp; &ensp; LocalFree                   (0x742c61b2)<br>
&emsp; &emsp; &ensp; MapViewOfFile               (0x4db4c713)<br>
&emsp; &emsp; &ensp; Sleep                       (0xd156a5be)<br>
&emsp; &emsp; &ensp; WaitForSingleObject         (0x8681d8fa)<br>
&emsp; &emsp; &ensp; lstrcatW                    (0x2ab51a99)<br>
&emsp; &emsp; &ensp; lstrcmpA                    (0x2abb9b4b)<br>
&emsp; user32.dll<br>
&emsp; &emsp; &ensp; EnumChildWindows            (0x9a8897c9)<br>
&emsp; &emsp; &ensp; EnumPropsA                  (0x8f0f57cf)<br>
&emsp; &emsp; &ensp; GetForegroundWindow         (0x5a6c9878)<br>
&emsp; &emsp; &ensp; GetKeyboardLayoutList       (0x04e9de30)<br>
&emsp; &emsp; &ensp; GetShellWindow              (0xd454e895)<br>
&emsp; &emsp; &ensp; GetWindowThreadProcessId    (0x576a5801)<br>
&emsp; &emsp; &ensp; SendMessageA                (0x41ecd315)<br>
&emsp; &emsp; &ensp; SendNotifyMessageA          (0xc6123bae)<br>
&emsp; &emsp; &ensp; SetPropA                    (0x90bc10d3)<br>
&emsp; &emsp; &ensp; wsprintfW                   (0x0bafd3f9)<br>
&emsp; advapi32.dll<br>
&emsp; &emsp; &ensp; GetTokenInformation         (0x696464ac)<br>
&emsp; &emsp; &ensp; OpenProcessToken            (0x74f5e377)<br>
&emsp; shell32.dll<br>
&emsp; &emsp; &ensp; ShellExecuteExW             (0xf8e40384)<br>
</details>

And here is the list of the imported functions from the copied ntdll (for anti-hooking):

<details style="color: #EEFFFF; font-family: monospace !default; font-size: 0.85em; background: #263238; border: 1px solid #263238; border-radius: 3px; padding: 10px; line-height: 1.8">
    <summary style="outline: none; cursor: pointer">
        <span style="color: darkgray">
            Expand to see more
        </span><br>
&emsp; 4DD3.tmp<br>
&emsp; &emsp; &ensp; NtAllocateVirtualMemory     (0x5a0c2ccc)<br>
&emsp; &emsp; &ensp; NtCreateSection             (0xd5f23ad0)<br>
&emsp; &emsp; &ensp; NtEnumerateKey              (0xb6306996)<br>
&emsp; &emsp; &ensp; NtFreeVirtualMemory         (0x2a6fa509)<br>
&emsp; &emsp; &ensp; NtMapViewOfSection          (0x870246aa)<br>
&emsp; &emsp; &ensp; NtOpenKey                   (0xc29efe42)<br>
&emsp; &emsp; &ensp; NtOpenProcess               (0x507bcb58)<br>
&emsp; &emsp; &ensp; NtQueryInformationProcess   (0xd6d488a2)<br>
&emsp; &emsp; &ensp; NtQueryKey                  (0xa9475346)<br>
</summary>
&emsp; &emsp; &ensp; NtQuerySystemInformation    (0xb83de8a8)<br>
&emsp; &emsp; &ensp; NtUnmapViewOfSection        (0x8352aa4d)<br>
&emsp; &emsp; &ensp; NtWriteVirtualMemory        (0x546899d2)<br>
&emsp; &emsp; &ensp; RtlDecompressBuffer         (0xdeb36606)<br>
&emsp; &emsp; &ensp; towlower                    (0xf7660ba8)<br>
&emsp; &emsp; &ensp; wcsstr                      (0xbb629f0b)<br>
</details>

## Anti VM

SmokeLoader enumerates all the subkeys of these keys:

- System\CurrentControlSet\Enum\IDE
- System\CurrentControlSet\Enum\SCSI

Then it transforms them into lowercase and searches for these strings in the enumerated keys names:

- qemu
- virtio
- vmware
- vbox
- xen

If one of them is found, the binary exits.

[![17](/assets/images/malware-analysis/smokeloader/17.png)](/assets/images/malware-analysis/smokeloader/17.png) | [![18](/assets/images/malware-analysis/smokeloader/18.png)](/assets/images/malware-analysis/smokeloader/18.png)

## Process Injection

SmokeLoader uses [PROPagate](http://www.hexacorn.com/blog/2017/10/26/propagate-a-new-code-injection-trick/) injection method to inject the next stage into `explorer.exe`.

First it decompresses the next stage using `RtlDecompressBuffer()`.

[![19](/assets/images/malware-analysis/smokeloader/19.png)](/assets/images/malware-analysis/smokeloader/19.png)

Then there is a call to `NtOpenProcess()` to open `explorer.exe` for the injection.

[![20](/assets/images/malware-analysis/smokeloader/20.png)](/assets/images/malware-analysis/smokeloader/20.png)

The injection process starts by creating two shared sections between the current process and explorer process (one section for the modified property and the other for the next stage's code), then SmokeLoader maps the created sections to the current process and explorer process memory space (so any changes in the sections will be reflected in explorer process).

Note that both sections have `"RWX"` protection which might raise some red flags by security solutions.

[![21](/assets/images/malware-analysis/smokeloader/21.png)](/assets/images/malware-analysis/smokeloader/21.png) | [![22](/assets/images/malware-analysis/smokeloader/22.png)](/assets/images/malware-analysis/smokeloader/22.png)

We can see that explorer got a handle to these two sections (this is similar to classic code injection but with much more stealth).

[![23](/assets/images/malware-analysis/smokeloader/23.png)](/assets/images/malware-analysis/smokeloader/23.png)

SmokeLoader then writes the next stage to one of the sections and the modified property (which will call the next stage's code) to the other section.

Finally, it sets the modified property using `SetPropA()` and sends a message to explorer window using `SendNotifyMessageA()`, this will result in the injected code being executed in the context of `explorer.exe`. 

[![24](/assets/images/malware-analysis/smokeloader/24.png)](/assets/images/malware-analysis/smokeloader/24.png)

# Stage 3

This is the final stage of SmokeLoader, it starts by doing some anti-analysis checks.

## Checking Running Processes

This stage loops through the running process, it calculates each process name's hash and compares it against some hardcoded hashes.

Here is the algorithm for calculating the hash of a process name:

```c
uint ROL(uint x, uint bits) {
	return x<<bits | x>>(32-bits);
}
int calc_hash(char *proc_name) {	
	int hash = 0;
	for(int i=0; i<strlen(proc_name); i++)
		hash = (proc_name[i] & 0xDF) + ROL(hash ^ (proc_name[i] & 0xDF), 8);
	return hash ^ 0xD781F33C;
}
```

A quick guess and I could get the processes names:

```
0xD384255C  →  Autoruns.exe
0x76BDCBAB  →  procexp.exe
0xA159E6BE  →  procexp64.exe
0x7E9CCCA5  →  procmon.exe
0xA24B8E63  →  procmon64.exe
0x63B3D1A4  →  Tcpview.exe
0xA28974F3  →  Wireshark.exe
0xA9B5F897  →  ProcessHacker.exe
0x6893EBAB  →  ollydbg.exe
0xF5FD94B7  →  x32dbg.exe
0xCBFD99B0  →  x64dbg.exe
0x8993DEE5  →  idaq.exe
0x8993D8CF  →  idaw.exe
0x8C083960  →  idaq64.exe
0xB6223960  →  idaw64.exe
```

If one of these processes is found to be running, `explorer.exe` will exit.

## Encrypted Strings

All strings of this stage are encrypted using `RC4` and they are decrypted on demand. The RC4 key = `0xFA5F66D7`.

The encrypted strings are stored continuously in a big blob in this form:

[![25](/assets/images/malware-analysis/smokeloader/25.png)](/assets/images/malware-analysis/smokeloader/25.png) | [![26](/assets/images/malware-analysis/smokeloader/26.png)](/assets/images/malware-analysis/smokeloader/26.png)

Here is a small script for decrypting these strings (I used Go because it has native support for RC4).

```go
package main
import (
	"fmt"
	"io/ioutil"
	"encoding/hex"
	"crypto/rc4"
)
var RC4_KEY, _ = hex.DecodeString("FA5F66D7")

func rc4_decrypt(data []byte) {
	cipher, _ := rc4.NewCipher(RC4_KEY)
	cipher.XORKeyStream(data, data)
	fmt.Printf("%s\n", data)
}
func main() {
	data, _ := ioutil.ReadFile("dump")
	for i := 0; i < len(data); {
		n := int(data[i])	
		rc4_decrypt(data[i+1:i+n+1])
		i += n+1
	}
}
```

And here is the decrypted strings:

<details style="color: #EEFFFF; font-family: monospace !default; font-size: 0.85em; background: #263238; border: 1px solid #263238; border-radius: 3px; padding: 10px; line-height: 2.2; overflow-x: scroll;">
    <summary style="outline: none; cursor: pointer">
        <span style="color: darkgray">
            Expand to see more
        </span><br>
<div style="height: 1px"></div>
&emsp; http://www.msftncsi.com/ncsi.txt<br>
&emsp; Software\Microsoft\Internet Explorer<br>
&emsp; advapi32.dll<br>
&emsp; Location:<br>
&emsp; plugin_size<br>
&emsp; \explorer.exe<br>
&emsp; user32<br>
</summary>
&emsp; advapi32<br>
&emsp; urlmon<br>
&emsp; ole32<br>
&emsp; winhttp<br>
&emsp; ws2_32<br>
&emsp; dnsapi<br>
&emsp; svcVersion<br>
&emsp; Version<br>
&emsp; &lt?xml version="1.0"?&gt&ltscriptlet&gt&ltregistration classid="{00000000-0000-0000-0000-00000000%04X}"&gt&ltscript language="jscript"&gt&lt![CDATA[GetObject("winmgmts:Win32_Process").Create("%ls",null,null,null);]]&gt&lt/script&gt&lt/registration&gt&lt/scriptlet&gt<br>
&emsp; S:(ML;;NW;;;LW)D:(A;;0x120083;;;WD)(A;;0x120083;;;AC)<br>
&emsp; %s\%hs<br>
&emsp; %s%s<br>
&emsp; regsvr32 /s %s<br>
&emsp; regsvr32 /s /n /u /i:"%s" scrobj<br>
&emsp; %APPDATA%<br>
&emsp; %TEMP%<br>
&emsp; .exe<br>
&emsp; .dll<br>
&emsp; :Zone.Identifier<br>
&emsp; POST<br>
&emsp; Content-Type: application/x-www-form-urlencoded<br>
&emsp; runas<br>
&emsp; Host: %s<br>
&emsp; PT10M<br>
&emsp; 1999-11-30T00:00:00<br>
&emsp; NvNgxUpdateCheckDaily_{&#37;08X-&#37;04X-&#37;04X-&#37;04X-&#37;08X&#37;04X}<br>
&emsp; Accept: */*<br>
&emsp; Referer: %S<br>
</details>
## Encrypted C2 Domains

The C2 domains are encrypted using simple XOR operations.

[![27](/assets/images/malware-analysis/smokeloader/27.png)](/assets/images/malware-analysis/smokeloader/27.png)

They are stored in a in this form:

[![28](/assets/images/malware-analysis/smokeloader/28.png)](/assets/images/malware-analysis/smokeloader/28.png) | [![29](/assets/images/malware-analysis/smokeloader/29.png)](/assets/images/malware-analysis/smokeloader/29.png)

We can easily decrypt the domains:

```python
def decrypt_c2(enc, key):
	enc, key = bytes.fromhex(enc), bytes.fromhex(key)
	dec = ""
	for c in enc:
		for i in key: c = c ^ i
		dec += chr(c ^ 0xE4)
	print(dec)

# decrypt_c2("E7FBFBFFB5A0A0E2E0FCFBEAFCFBA2FCEAFDF9E6ECEABFBEBDBABFBAA1FDFAA0", "EFC11A5F")
# http://mostest-service012505.ru/
```

## C2 Communications

SmokeLoader sleeps for 10 seconds (1000*10) before connecting to the Internet.

[![30](/assets/images/malware-analysis/smokeloader/30.png)](/assets/images/malware-analysis/smokeloader/30.png)

First it queries `http://www.msftncsi.com/ncsi.txt` (This URL is usually queried by Windows to determine if the computer is connected to the Internet).

If there's no response, it sleeps for `64 ms` and queries it again until it receives a response.

Then SmokeLoader sends a `POST` request to the C2 server. The payload is encrypted using `RC4` before sending it.

 The `POST` request returns a `"404 Not Found"` response but it contains a payload in the response body.

[![31](/assets/images/malware-analysis/smokeloader/31.png)](/assets/images/malware-analysis/smokeloader/31.png)

Unfortunately most of the C2 domains are down so I couldn't proceed with the analysis, but I think that's enough with SmokeLoader :) 

# IOCs

#### <u>Hashes</u>

SmokeLoader fc20b03299b8ae91e72e104ee4f18e40125b2b061f1509d1c5b3f9fac3104934

#### <u>Files</u>

%TEMP%\4dd3.dll

#### <u>C2 Domains</u>

http://alltest-service012505[.]ru/<br>
http://besttest-service012505[.]ru/<br>
http://biotest-service012505[.]ru/<br>
http://clubtest-service012505[.]ru/<br>
http://domtest-service012505[.]ru/<br>
http://infotest-service012505[.]ru/<br>
http://kupitest-service012505[.]ru/<br>
http://megatest-service012505[.]ru/<br>
http://mirtest-service012505[.]ru/<br>
http://mostest-service012505[.]ru/<br>
http://mytest-service01242505[.]ru/<br>
http://mytest-service012505[.]ru/<br>
http://newtest-service012505[.]ru/<br>
http://proftest-service012505[.]ru/<br>
http://protest-01242505[.]tk/<br>
http://protest-01252505[.]ml/<br>
http://protest-01262505[.]ga/<br>
http://protest-01272505[.]cf/<br>
http://protest-01282505[.]gq/<br>
http://protest-01292505[.]com/<br>
http://protest-01302505[.]net/<br>
http://protest-01312505[.]org/<br>
http://protest-01322505[.]biz/<br>
http://protest-01332505[.]info/<br>
http://protest-01342505[.]eu/<br>
http://protest-01352505[.]nl/<br>
http://protest-01362505[.]mobi/<br>
http://protest-01372505[.]name/<br>
http://protest-01382505[.]me/<br>
http://protest-01392505[.]garden/<br>
http://protest-01402505[.]art/<br>
http://protest-01412505[.]band/<br>
http://protest-01422505[.]bargains/<br>
http://protest-01432505[.]bet/<br>
http://protest-01442505[.]blue/<br>
http://protest-01452505[.]business/<br>
http://protest-01462505[.]casa/<br>
http://protest-01472505[.]city/<br>
http://protest-01482505[.]click/<br>
http://protest-01492505[.]company/<br>
http://protest-01502505[.]futbol/<br>
http://protest-01512505[.]gallery/<br>
http://protest-01522505[.]game/<br>
http://protest-01532505[.]games/<br>
http://protest-01542505[.]graphics/<br>
http://protest-01552505[.]group/<br>
http://protest-02252505[.]ml/<br>
http://protest-02262505[.]ga/<br>
http://protest-02272505[.]cf/<br>
http://protest-02282505[.]gq/<br>
http://protest-03252505[.]ml/<br>
http://protest-03262505[.]ga/<br>
http://protest-03272505[.]cf/<br>
http://protest-03282505[.]gq/<br>
http://protest-05242505[.]tk/<br>
http://protest-06242505[.]tk/<br>
http://protest-service01242505[.]ru/<br>
http://protest-service012505[.]ru/<br>
http://rustest-service012505[.]ru/<br>
http://rutest-service01242505[.]ru/<br>
http://rutest-service012505[.]ru/<br>
http://shoptest-service012505[.]ru/<br>
http://supertest-service012505[.]ru/<br>
http://test-service01242505[.]ru/<br>
http://test-service012505[.]com/<br>
http://test-service012505[.]eu/<br>
http://test-service012505[.]fun/<br>
http://test-service012505[.]host/<br>
http://test-service012505[.]info/<br>
http://test-service012505[.]net/<br>
http://test-service012505[.]net2505[.]ru/<br>
http://test-service012505[.]online/<br>
http://test-service012505[.]org2505[.]ru/<br>
http://test-service012505[.]pp2505[.]ru/<br>
http://test-service012505[.]press/<br>
http://test-service012505[.]pro/<br>
http://test-service012505[.]pw/<br>
http://test-service012505[.]ru[.]com/<br>
http://test-service012505[.]site/<br>
http://test-service012505[.]space/<br>
http://test-service012505[.]store/<br>
http://test-service012505[.]su/<br>
http://test-service012505[.]tech/<br>
http://test-service012505[.]website/<br>
http://test-service012505[.]xyz/<br>
http://test-service01blog2505[.]ru/<br>
http://test-service01club2505[.]ru/<br>
http://test-service01forum2505[.]ru/<br>
http://test-service01info2505[.]ru/<br>
http://test-service01land2505[.]ru/<br>
http://test-service01life2505[.]ru/<br>
http://test-service01plus2505[.]ru/<br>
http://test-service01pro2505[.]ru/<br>
http://test-service01rus2505[.]ru/<br>
http://test-service01shop2505[.]ru/<br>
http://test-service01stroy2505[.]ru/<br>
http://test-service01torg2505[.]ru/<br>
http://toptest-service012505[.]ru/<br>
http://vsetest-service012505[.]ru/<br>

# References

[https://www.cert.pl/en/news/single/dissecting-smoke-loader/](https://www.cert.pl/en/news/single/dissecting-smoke-loader/)

[https://research.checkpoint.com/2019/2019-resurgence-of-smokeloader/](https://research.checkpoint.com/2019/2019-resurgence-of-smokeloader/)

[https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb](https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb)

[https://www.aldeid.com/wiki/PEB-Process-Environment-Block](https://www.aldeid.com/wiki/PEB-Process-Environment-Block)

[http://www.hexacorn.com/blog/2017/10/26/propagate-a-new-code-injection-trick](http://www.hexacorn.com/blog/2017/10/26/propagate-a-new-code-injection-trick)

[https://modexp.wordpress.com/2018/08/23/process-injection-propagate/](https://modexp.wordpress.com/2018/08/23/process-injection-propagate/)

[https://docs.microsoft.com/en-us/windows/win32/api/winhttp/nf-winhttp-winhttpconnect#examples](https://docs.microsoft.com/en-us/windows/win32/api/winhttp/nf-winhttp-winhttpconnect#examples)

[https://www.crowdstrike.com/blog/maze-ransomware-deobfuscation/](https://www.crowdstrike.com/blog/maze-ransomware-deobfuscation/)

